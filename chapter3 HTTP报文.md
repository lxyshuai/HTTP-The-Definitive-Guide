## 报文流
### 报文流流入源端服务器
### 报文向下游流动









## 报文的组成部分

*  HTTP报文是简单的格式化数据块.
*  由三个部分组成:
	1. 对报文进行描述的起始行
	2. 包含属性的首部
	3. 可选的包含数据的主体
* 起始行和首部就是由行分隔的ASCII文本.每行都以一个由两个字符组成的行终止序列作为结束,其中包括一个回车符(13)和一个换行符(10).这个行终止序列可以写做CRLF
* 实体的主体或报文的主体是一个可选的数据块,看包含文本或二进制数据,也可以为空



### 报文语法

* 请求报文格式:

```
<method> <request-URL> <version>
<headers>

<entity-body>
```

* 请求报文格式:

```
<version> <status> <reason-phrase>
<headers>

<entity-body>
```

* 方法(method):客户端希望服务器对资源执行的动作
* 请求URL(request-URL):命名了所请求的资源,或者URL路径组件的完整URL
* 版本(version):报文所使用的HTTP版本,格式``HTTP/<major>/<minor>``
* 状态码(status-code):描述了请求过程发生的情况,每个状态码的第一位数字用于描述状态的一般类别
* 原因短语(reason-phrase):数字状态码的可读版本
* 首部(header):可以有0个或多个首部,``key:value``.首部是由一个空行(CRLF)结束,表示首部列表的结束和实体主体部分的开始
* 实体主体部分:实体的主体部分包含一个由任意数据组成的数据块.并不是所有的报文都包含实体的主体部分,有时,报文只是以一个CRLF结束
1. Select the Solution Type

3. Coordinate System Settings

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 起始行

1. 请求行
  * 请求报文请求服务器对资源进行一些操作
  * 请求行包含一个方法(描述了服务器一个执行的操作)、一个请求URL(描述了要对哪个资源执行这个方法)和HTTP版本(告知服务器客户端使用的是那种HTTP).
  * 所有这些字段都由空格符分隔
2. 响应行
  * 响应报文承载了状态信息和操作产生的所有结果数据
  * 响应行包含HTTP版本、数字状态码和描述操作状态的文本形式的原因短语
3. 方法
  * 常用的HTTP方法
	| 方法 | 描述 | 是否包含主体 |
	|:-------:|:--------------------------------------------------:|:------------:|
	| GET | 从服务器获得一份文档 | 否 |
	| HEAD | 只从服务器获取文档的首部 | 否 |
	| POST | 想服务器发送需要处理的数据 | 是 |
	| PUT | 将请求的主体部分存储在服务器上 | 是 |
	| TRACE | 对可能经过代理服务器传送到服务器上去的报文进行追踪 | 否 |
	| OPTIONS | 决定考研在服务器执行哪些方法 | 否 |
	| DELETE | 从服务器上删除一份文档 | 否 |

4. 状态码
	* 状态码告诉客户端,发生了什么事情
	| 整体方位 | 已定义范围 | 分类 |
	|:--------:|:----------:|:----------:|
	| 100-199 | 100-101 | 信息提示 |
	| 200-299 | 200-206 | 成功 |
	| 300-399 | 300-305 | 重定向 |
	| 400-499 | 400-415 | 客户端错误 |
	| 500-599 | 500-505 | 服务端错误 |

5. 原因短语

  * 为状态码提供文本形式的解释

6. 版本号
	TODO



### 首部

* HTTP首部字段向请求和响应报文中添加一些附加信息.本质上来说,它们只是一些key/value的列表
1. 首部分类
	* 通用首部:既可以出现在请求报文中,也可以出现在响应报文中
	* 请求首部:提供更多有关请求的信息
	* 响应首部:提供更多有关响应的信息
	* 实体首部:描述主体的长度和内容,或者资源本身
	* 扩展首部:规范中没有的新首部
	* 每个HTTP首部都有一种简单的语法:名字后面跟着冒号(:),然后跟上可选的空格,再跟上字段值,最后是一个CRLF
2. 首部延续行
	* 将长的首部氛围多行提高可读性,读出来的每行前面至少要有一个空格或制表符



### 实体的主体部分

* 实体的主体是HTTP报文的符合,就是HTTP要传输的内容









## 方法



### 安全方法:

* GET和HEAD被认为是安全方法,这就意味着使用GET和HEAD方法的HTTP请求不会产生什么动作



### GET

* 最常用方法,用于请求服务器发送某资源
* HTTP/1.1要求服务器实现此方法



### HEAD

* HEAD方法与GET方法的行为很类似,但服务器在响应中只返回首部,不会返回实体的主体的部分
* 这就允许客户端在未获取实际资源的情况下,对资源的首部进行检查
* 使用HEAD,可以:
	* 在不获取资源的情况下了解资源情况(比如,判断其类型)
	* 查看响应中的状态码,看看某个对象是否存在
	* 通过查看首部,测试资源是否被修改
* 服务器开发者必须确保返回的首部与GET请求所返回的首部完全相同



### PUT

* PUT方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档,或者,如果那个URL已经存在的话,就用这个主体替代
* 因为PUT运行用户对内容进行修改,所以使用PUT之前,应用密码登录



### POST

* POST方法起初用来向服务器输入数据.实际上,通常会用来支持HTML表单



### TRACE

* 客户端发起一个请求,这个请求可能要穿过防火墙、网关、代理或其他一些应用程序。每个中间节点都可能会修改原始HTTP请求。TRACE方法允许客户端在最终把请求发送给服务器时候，看看它变成什么样子
* TRACE请求会在目的服务器端发起一个"环回"诊断.行程最后一站的服务器会弹回一条TRACE响应,并在响应主体中携带它收到原始请求报文
* TRACE方法主要用于诊断,用于验证请求是否如愿穿过了请求/响应链,用来查看代理和其他应用程序对用户请求所产生的效果
* 优缺点,它嘉定中间应用程序对不同类型请求处理是相同的,TRACE并不提供区分这些方法的机制.通常,中间应用程序会自行决定对TRACE请求的处理方式
* TRACE请求中不能带有实体的主体部分.
* TRACE响应的实体主体部分包含响应服务器收到的请求的精确副本



### OPTIONS

* OPTIONS方法请求Web服务器告知其支持的各种功能



### DELETE

* 请服务器删除请求URL所指定的资源
* 客户端应用程序无法保证删除操作一定执行,因为HTTP规范允许服务器在不通知客户端的情况下撤销请求



### 扩展方法

TODO





## 状态码
### 100-199(信息性状态码)
| 状态码 | 原因短语 | 含义 |
|:------:|:-------------------:|:-------------------------------------------------------------------------------------------:|
| 100 | Continue | 说明收到了请求的初始部分,请客户端继续.发送了这个状态码之后,服务器在收到请求之后必须进行响应 |
| 101 | Switching Protocols | 说明服务器正在根据客户端的指定,将协议切换成Update首部所列的协议 |

1. 客户端与100 Continue
    如果客户端在向服务器发送一个实体，并且愿意在发送实体之前等待 100 Continue 响应，那么，客户端就要发送一个携带了值为 100 Continue 的 Expect 请求首部（参见附录C）。如果客户端没有发送实体，就不应该发送 100 Continue Expect 首部，因为这样会使服务器误以为客户端要发送一个实体。

2. 服务器与100 Continue如果服务器收到了一条带有值为 100 Continue 的 Expect 首部的请求，它会用 100 Continue 响应或一条错误码来进行响应。服务器永远也不应该向没有发送 100 Continue 期望的客户端发送 100 Continue 状态码。

    如果出于某种原因，服务器在有机会发送 100 Continue 响应之前就收到了部分（或全部）的实体，就说明客户端已经决定继续发送数据了，这样，服务器就不需要发送这个状态码了。但服务器读完请求之后，还是应该为请求发送一个最终的状态码（它可以跳过 100 Continue 状态）

3. 代理与100 Continue如果代理从客户端收到了一条带有 100 Continue 期望的请求，它需要做几件事情。如果代理知道下一跳服务器是 HTTP/1.1 兼容的，或者并不知道下一跳服务器与哪个版本兼容，它都应该将 Expect 首部放在请求中向下转发。如果它知道下一跳服务器只能与 HTTP/1.1 之前的版本兼容，就应该以 417 Expectation Failed 错误进行响应。

    如果代理决定代表与 HTTP/1.0 或之前版本兼容的客户端，在其请求中放入 Expect 首部和 100 Continue 值，那么，（如果它从服务器收到了 100 Continue 响应）它就不应该将 100 Continue 响应转发给客户端，因为客户端可能不知道该拿他怎么办。





### 200-299(成功状态码)

| 状态码 |           原因短语            |                             含义                             |
| :----: | :---------------------------: | :----------------------------------------------------------: |
|  200   |              OK               |         请求没问题,实体的主体部分包含了所请求的资源          |
|  201   |            Created            | 用于创建服务器对象的请求.响应的实体主体部分中应该包含各种引用了已创建的资源的URL,LOCATION首部包含的这是最具体的引用.服务器必须在发送这个状态码之前创建好对象 |
|  202   |           Accepted            | 请求已经接受,但服务器还未对其执行任何动作.不能保证服务器会完成这个请求;这只是意味着接受请求时,它看起来是有效的.服务器应该在实体的主体部分包含对请求状态的描述,或许还应该有对请求完成时间的估计(或者包含一个指针,指向可以获取此信息的位置) |
|  203   | Not-Authoritative Information | 实体首部包含的信息不是来自源端服务器,而是来自资源的一份副本.如果中间节点上有一份资源副本,但无法或者没有对它所发送的与资源有关的元信息(首部)进行验证. 这种响应吗并不是非用不可的; 如果实体首部来自源端服务器,响应为200状态的应用程序就可以将其作为一种可选性使用 <br>203 非权威内容，简单的说，就是通过代理访问原始服务器的时候，成功获取了原始服务器（状态200）的返回内容，但是代理对内容做出了一些改动，例如修改了文档编码等等，代理通过这个状态码告知用户，成功获取内容，但是这部分内容和原始服务器的返回内容可能不完全一致。 |
|  204   |          No Content           | 响应报文中包含若干首部和一个状态行,但是没有实体的主体部分.主要用于在浏览器不转为显示新文档的情况下,对其进行更新(比如刷新一个表单页面) |
|  205   |         Reset Content         | 另外一个主要用于浏览器的带吗.负责告知浏览器清楚当前页面中的所有HTML表单元素 |
|  206   |        Partial Content        | 成功执行了一个部分或Range(范围请求).稍后我们会看到,客户端可以通过一个特殊的首部来获取部分或某个范围内的文档--这个状态码就说明方位请求成功. <br>206响应中必须包含Content-Range、Date以及ETag或Content-Location首部 |



### 300-399(重定向状态码)

* 重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源,要么就提供一个替代的响应而不是资源的内容.如果资源已被移动,可发送一个重定向状态码和一个可选的Location首部告诉客户端资源被移走,以及现在可以在哪里找到它.这样浏览器就可以再不打扰的使用者的情况下,透明地转入新的位置
* 可以通过某些重定向状态码读资源的应用程序本地副本与源端服务器上的资源进行验证.比如HTTP应用程序可以查看其资源的本地副本是否仍然是最新的,或者在源端服务器上资源是否被修改过
* 总之,在对那些包含了重定向状态码的非HEAD请求进行响应时,最好要包含一个实体,并在实体中包含描述信息和指向(多个)重定向URL链接

| 状态码 | 原因短语           | 含义                                                         |
| ------ | ------------------ | ------------------------------------------------------------ |
| 300    | Multiple Choices   | 客户端请求一个实际指向多个资源的URL时会返回这个状态码,比如服务器上有某个HTML文档的英语和法语版本,返回这个代码时会带有一个选项列表:这样用户就可以选择他希望使用的那一项.服务器可以再Location首部包含首选URL |
| 301    | Moved Permanently  | 在请求的URL已被移除时使用.响应的Location首部中应该包含资源选择所在的URL |
| 302    | Found              | 与301状态码类似;但是,客户端应该使用Location首部给出的URL来定位资源.将来的请求仍应使用老的URL |
| 303    | See Other          | 告知客户端应该用另外一个URL来获取资源.新的URL位于响应报文的Location首部.其主要目的是允许POST请求的响应将客户端定向到某个资源上去 |
| 304    | Not Modified       | 客户端可以通过所包含的请求首部,使其请求变成有条件的.如果客户端发起一个条件为GET请求,而最近资源未被修改的话,就可以用这个状态码来说明资源未被修改.带有这个状态码的响应不应该包含实体的主体部分 |
| 305    | Use Proxy          | 用来说明必须通过一个代理来访问资源;代理的位置由Location首部给出.很重要的一点是,客户端使相对某个特定资源来解析这个响应的,不能嘉定所有请求,甚至所有对持有所请求资源的服务器请求都通过这个代理进行.如果客户端错误地让代理介入了某条请求,可能会引发破坏性的行为,而且会造成安全漏洞 |
| 306    | (未使用)           | 当前未使用                                                   |
| 307    | Temporary Redirect | 与301状态码类似;但客户端应该使用Location首部给出的URL来定位临时资源.将来的请求应该使用老的URL |

* **http1.0**:
  * **301**: 
    * 301状态码在HTTP 1.0和HTTP 1.1规范中均代表永久重定向，对于资源请求，原来的url和响应头中location的url而言，资源应该对应location中的url。对于post请求的重定向，还是需要用户确认之后才能重定向，并且应该以post方法发出重定向请求。
    * 关于post请求重定向用户确认的问题，实际上浏览器都没有实现；而且post请求的重定向应该发起post请求，这里浏览器也并不一定遵守，所以说HTTP规范的实现并未严格按照HTTP规范的语义。
    * 在301中资源对应的路径修改为location的url，在SEO中并未出现问题，但是在302中就出现了302劫持问题，请往下看。
  * **302**:
    *  在http 1.0规范中，302表示临时重定向，location中的地址不应该被认为是资源路径，在后续的请求中应该继续使用原地址。 
    * 规范：原请求是post，则不能自动进行重定向；原请求是get，可以自动重定向； 
    * 实现：浏览器和服务器的实现并没有严格遵守HTTP中302的规范，服务器不加遵守的返回302，浏览器即便原请求是post也会自动重定向，导致规范和实现出现了二义性，由此衍生了一些问题，譬如302劫持，因此在HTTP 1.1中将302的规范细化成了303和307，希望以此来消除二义性。
    *  补充：302劫持——A站通过重定向到B站的资源xxoo，A站实际上什么都没做但是有一个比较友好的域名，web资源xxoo存在B站并由B站提供，但是B站的域名不那么友好，因此对搜索引擎而言，可能会保存A站的地址对应xxoo资源而不是B站，这就意味着B站出了资源版权、带宽、服务器的钱，但是用户通过搜索引擎搜索xxoo资源的时候出来的是A站，A站什么都没做却被索搜引擎广而告之用户，B站做了一切却不被用户知道，价值被A站窃取了。 
* http1.1
  * **301**
    * 和http 1.0规范中保持一致，注意资源对应的路径应该是location中返回的url，而不再是原请求地址。 
  * **302**
    * 在HTTP 1.1中，实际上302是不再推荐使用的，只是为了兼容而作保留。规范中再次重申只有当原请求是GET or HEAD方式的时候才能自动的重定向，为了消除HTTP 1.0中302的二义性，在HTTP 1.1中引入了303和307来细化HTTP 1.0中302的语义。 
  * **303**
    * 在HTTP 1.0的时候，302的规范是原请求是post不可以自动重定向，但是服务器和浏览器的实现是运行重定向。 
    * 把HTTP 1.0规范中302的规范和实现拆分开，分别赋予HTTP 1.1中303和307，因此在HTTP 1.1中，303继承了HTTP 1.0中302的实现（即原请求是post，也允许自动进行重定向，结果是无论原请求是get还是post，都可以自动进行重定向），而307则继承了HTTP 1.0中302的规范（即如果原请求是post，则不允许进行自动重定向，结果是post不重定向，get可以自动重定向）。 
  * **307**
    * 在http 1.1规范中，307为临时重定向，注意划红线的部分，如果重定向307的原请求不是get或者head方法，那么浏览器一定不能自动的进行重定向，即便location有url，也应该忽略。 
    * 也就是307继承了302在HTTP 1.0中的规范（303继承了302在HTTP 1.0中的实现）。 



### 400-499(客户端错误状态码)

* 很多客户端错误都是由浏览器来处理,只有少量错误穿过浏览器来到用户面前

| 状态码 | 原因短语                        | 含义                                                         |
| ------ | ------------------------------- | ------------------------------------------------------------ |
| 400    | Bad Request                     | 用于告知客户端它发送了一个错误请求                           |
| 401    | Unauthorized                    | 与适当的首部一同返回,在这些中请求客户端在获取对象            |
| 402    | Payment Required                | 还未使用                                                     |
| 403    | Forbidden                       | 用于说明被服务器拒绝了.如果服务器想说明为什么拒绝请求,可包含实体的主体部分来对原因进行描述.但这个状态码通常是在服务器不像说明拒绝原因的时候使用 |
| 404    | Not Found                       | 用于说明服务器无法找到说请求的URL.通常会包含一个实体,以便客户端应用程序显示给用户看 |
| 405    | Method Not Allowed              | 发起的请求中带有所请求的URL不支持的方法时,使用此状态码,应该在响应中包含Allow首部,以告知客户端对所请求的资源可以使用那些方法 |
| 406    | Not Acceptable                  | 客户端可以指定参数来说明它们愿意接收说明类型的实体.服务器没有与客户端可接收的URL相匹配的资源时,使用此代码.通常,服务器会包含一些首部,以便客户端弄清楚为什么请求无法满足. |
| 407    | Proxy Authentication Required   | 与401状态码类似,但用于要求对资源进行保证的代理服务器         |
| 408    | Request Timeout                 | 如果客户端完成请求所花的时间太长,服务器可以会送此状态码,并关闭连接.超时时长随服务器的不同而不同,但通常对所有的合法请求来说都是够长的 |
| 409    | Conflict                        | 用于说明请求可能在资源上引发的一些冲突.服务器担心请求引发冲突时,可以发送此状态码.响应中应该包含描述冲突的主体 |
| 410    | Gone                            | 与404类似,只是服务器曾经拥有过此资源.主要用于Web站点的维护,这样服务器的管理者就可以再资源被移除的情况下通知客户端 |
| 411    | Length Required                 | 服务器要求在请求报文中包含Content-Length首部时使用           |
| 412    | Precondition Failed             | 客户端发起条件请求,且其中一个条件失败了的时候使用.客户端包含了Expect首部时发起的就是条件请求 |
| 413    | Request Entity Too Large        | 客户端发送的实体主体部分比服务器能够或者希望处理的要大时,使用此状态码 |
| 414    | Request URI Too Long            | 客户端所发请求中的请求URL比服务器能够或者希望处理的要长时,使用此状态码 |
| 415    | Unsupported Media Type          | 服务器无法理解或无法支持客户端所发实体的内容类型时,使用此状态码 |
| 416    | Requested Range Not Satisfiable | 请求报文所请求的是指定资源的某个范围,而此范围无效后无法满足时,使用此状态码 |
| 417    | Expectation Failed              | 请求的Expect请求首部包含一个期望,但服务器无法满足此期望时,使用此状态码.如果代理或其他中间应用程序有确切证据说明源端服务器会为某请求产生一个失败的期望,就可以发送这个响应状态码 |

